/**
 * üîî WEBHOOK ROUTES - RECEBER EVENTOS DA EVOLUTION API
 * 
 * Endpoints para receber webhooks da Evolution API:
 * - POST /webhook/evolution - Recebe todos os eventos
 * - GET /webhook/evolution - Health check do webhook
 */

const express = require('express');
const router = express.Router();

/**
 * üîî ENDPOINT PRINCIPAL DO WEBHOOK
 * A Evolution API enviar√° eventos para este endpoint
 */
router.post('/evolution', async (req, res) => {
    try {
        const webhookData = req.body;
        
        // Log detalhado para debug
        console.log('üîî =================================');
        console.log('üì• WEBHOOK EVOLUTION API RECEBIDO');
        console.log('üîî =================================');
        console.log('üìÖ Timestamp:', new Date().toISOString());
        console.log('üéØ Evento:', webhookData.event);
        console.log('üì± Inst√¢ncia:', webhookData.instance);
        
        // Log completo do body apenas em desenvolvimento
        if (process.env.NODE_ENV !== 'production') {
            console.log('üìã Body completo:', JSON.stringify(webhookData, null, 2));
        }
        
        // Obter inst√¢ncia do servi√ßo webhook da Evolution
        const evolutionWebhookService = req.app.get('evolutionWebhookService');
        
        if (!evolutionWebhookService) {
            console.error('‚ùå EvolutionWebhookService n√£o encontrado no app');
            return res.status(500).json({
                success: false,
                error: 'Servi√ßo webhook n√£o configurado'
            });
        }
        
        // Processar webhook
        const result = await evolutionWebhookService.processWebhook(webhookData);
        
        if (result.success) {
            console.log(`‚úÖ Webhook processado: ${result.action || 'unknown'}`);
            
            // Resposta de sucesso para Evolution API
            res.status(200).json({
                success: true,
                message: 'Webhook processado com sucesso',
                processed: true,
                event: webhookData.event,
                instance: webhookData.instance,
                action: result.action,
                timestamp: new Date().toISOString()
            });
        } else {
            console.error(`‚ùå Erro no processamento webhook: ${result.error}`);
            
            // Resposta de erro mas HTTP 200 para n√£o reenvio
            res.status(200).json({
                success: false,
                message: 'Erro no processamento mas webhook recebido',
                error: result.error,
                event: webhookData.event,
                instance: webhookData.instance,
                timestamp: new Date().toISOString()
            });
        }
        
    } catch (error) {
        console.error('‚ùå Erro cr√≠tico no webhook:', error.message);
        console.error('üîç Stack:', error.stack);
        
        // Sempre responder 200 para n√£o reenvio
        res.status(200).json({
            success: false,
            error: 'Erro interno do webhook',
            message: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

/**
 * ‚úÖ HEALTH CHECK DO WEBHOOK
 * Para verificar se o webhook est√° funcionando
 */
router.get('/evolution', (req, res) => {
    console.log('‚úÖ Health check do webhook Evolution');
    
    const evolutionWebhookService = req.app.get('evolutionWebhookService');
    const cacheStats = evolutionWebhookService ? evolutionWebhookService.getCacheStats() : null;
    
    res.json({
        status: 'webhook_active',
        service: 'Evolution API Webhook',
        timestamp: new Date().toISOString(),
        webhook_url: process.env.WEBHOOK_URL || 'http://localhost:8000/webhook/evolution',
        cache_stats: cacheStats,
        message: 'Webhook pronto para receber eventos da Evolution API',
        supported_events: [
            'QRCODE_UPDATED',
            'CONNECTION_UPDATE', 
            'MESSAGES_UPSERT',
            'MESSAGE_STATUS_UPDATE',
            'PRESENCE_UPDATE',
            'CHATS_UPSERT',
            'CONTACTS_UPSERT',
            'GROUPS_UPSERT'
        ]
    });
});

/**
 * üìä ESTAT√çSTICAS DO WEBHOOK
 */
router.get('/evolution/stats', (req, res) => {
    console.log('üìä Estat√≠sticas do webhook requisitadas');
    
    try {
        const evolutionWebhookService = req.app.get('evolutionWebhookService');
        
        if (!evolutionWebhookService) {
            return res.status(404).json({
                success: false,
                error: 'Servi√ßo webhook n√£o encontrado'
            });
        }
        
        const stats = evolutionWebhookService.getCacheStats();
        
        res.json({
            success: true,
            data: stats,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro ao obter estat√≠sticas webhook:', error.message);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * üßπ LIMPAR CACHE EXPIRADO
 */
router.post('/evolution/cleanup', (req, res) => {
    console.log('üßπ Limpeza de cache solicitada');
    
    try {
        const evolutionWebhookService = req.app.get('evolutionWebhookService');
        
        if (!evolutionWebhookService) {
            return res.status(404).json({
                success: false,
                error: 'Servi√ßo webhook n√£o encontrado'
            });
        }
        
        const cleaned = evolutionWebhookService.cleanExpiredCache();
        
        res.json({
            success: true,
            message: 'Limpeza conclu√≠da',
            cleaned_items: cleaned,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro na limpeza de cache:', error.message);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * üîç DEBUG - LISTAR QR CODES EM CACHE
 */
router.get('/evolution/debug/qrcodes', (req, res) => {
    if (process.env.NODE_ENV === 'production') {
        return res.status(403).json({
            success: false,
            error: 'Debug n√£o dispon√≠vel em produ√ß√£o'
        });
    }
    
    console.log('üîç Debug QR codes solicitado');
    
    try {
        const evolutionWebhookService = req.app.get('evolutionWebhookService');
        
        if (!evolutionWebhookService) {
            return res.status(404).json({
                success: false,
                error: 'Servi√ßo webhook n√£o encontrado'
            });
        }
        
        // Acessar cache interno para debug
        const qrCodes = Array.from(evolutionWebhookService.qrCodeCache.entries()).map(([instance, data]) => ({
            instance: instance,
            has_qrcode: !!data.qrcode,
            timestamp: new Date(data.timestamp).toISOString(),
            expires_at: new Date(data.expires_at).toISOString(),
            status: data.status,
            source: data.source,
            time_remaining: Math.max(0, data.expires_at - Date.now()),
            expired: Date.now() > data.expires_at
        }));
        
        res.json({
            success: true,
            data: qrCodes,
            total: qrCodes.length,
            active: qrCodes.filter(qr => !qr.expired).length,
            expired: qrCodes.filter(qr => qr.expired).length,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro no debug QR codes:', error.message);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;