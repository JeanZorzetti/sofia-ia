/**
 * üéØ EVOLUTION API WEBHOOK SERVICE - BASEADO NA DOCUMENTA√á√ÉO OFICIAL
 * 
 * Implementa√ß√£o correta conforme Evolution API v2:
 * - QR codes v√™m via webhook QRCODE_UPDATED
 * - Payload correto de cria√ß√£o com webhook configurado
 * - Cache local de QR codes recebidos via webhook
 * - Fluxo correto: CREATE ‚Üí WEBHOOK ‚Üí CACHE ‚Üí FRONTEND
 */

const axios = require('axios');

class EvolutionWebhookService {
    constructor() {
        this.apiUrl = process.env.EVOLUTION_API_URL || 'https://evolutionapi.roilabs.com.br';
        this.apiKey = process.env.EVOLUTION_API_KEY || 'SuOOmamlmXs4NV3nkxpHAy7z3rcurbIz';
        this.webhookUrl = process.env.WEBHOOK_URL || 'http://localhost:8000/webhook/evolution';
        
        // üì± Cache para QR codes recebidos via webhook
        this.qrCodeCache = new Map();
        this.instanceStatusCache = new Map();
        
        this.defaultHeaders = {
            'apikey': this.apiKey,
            'Content-Type': 'application/json'
        };
        
        console.log('üîî Evolution Webhook Service inicializado');
        console.log(`üìç API URL: ${this.apiUrl}`);
        console.log(`üîî Webhook URL: ${this.webhookUrl}`);
    }

    /**
     * üÜï CRIAR INST√ÇNCIA COM WEBHOOK CONFIGURADO
     * Baseado na documenta√ß√£o oficial da Evolution API
     */
    async createInstanceWithWebhook(instanceName) {
        try {
            console.log(`üÜï Criando inst√¢ncia ${instanceName} com webhooks`);
            
            // ‚úÖ PAYLOAD OFICIAL baseado na documenta√ß√£o
            const instanceData = {
                instanceName: instanceName,
                qrcode: true,
                integration: 'WHATSAPP-BAILEYS',
                
                // üîî CR√çTICO: Webhook configuration
                webhookUrl: this.webhookUrl,
                webhookByEvents: true,
                webhookBase64: true,
                webhookEvents: [
                    'QRCODE_UPDATED',      // üì± Para receber QR codes
                    'CONNECTION_UPDATE',   // üîó Para status de conex√£o
                    'MESSAGES_UPSERT'      // üí¨ Para mensagens
                ],
                
                // ‚öôÔ∏è Configura√ß√µes WhatsApp otimizadas
                rejectCall: true,
                msgCall: 'Sofia IA n√£o aceita chamadas. Use mensagens de texto.',
                groupsIgnore: true,
                alwaysOnline: true,
                readMessages: true,
                readStatus: false,
                syncFullHistory: false
            };
            
            const response = await axios.post(`${this.apiUrl}/instance/create`, instanceData, {
                headers: this.defaultHeaders,
                timeout: 30000
            });
            
            // ‚úÖ Response da cria√ß√£o (SEM QR code - vir√° via webhook)
            const result = {
                success: true,
                data: {
                    instanceName: response.data.instance.instanceName,
                    instanceId: response.data.instance.instanceId,
                    status: response.data.instance.status || 'created',
                    apikey: response.data.hash?.apikey,
                    settings: response.data.settings,
                    message: 'Inst√¢ncia criada. QR code ser√° enviado via webhook.'
                }
            };
            
            // Inicializar status no cache
            this.instanceStatusCache.set(instanceName, {
                status: 'created',
                created_at: new Date().toISOString(),
                last_update: new Date().toISOString()
            });
            
            console.log(`‚úÖ Inst√¢ncia ${instanceName} criada. Aguardando QR via webhook...`);
            return result;
            
        } catch (error) {
            console.error(`‚ùå Erro ao criar inst√¢ncia ${instanceName}:`, error.message);
            
            if (error.response?.status === 409) {
                console.log(`‚ö†Ô∏è Inst√¢ncia ${instanceName} j√° existe`);
                return {
                    success: false,
                    error: 'Instance already exists',
                    existing: true
                };
            }
            
            return {
                success: false,
                error: error.message,
                details: error.response?.data
            };
        }
    }

    /**
     * üîî PROCESSAR WEBHOOK DA EVOLUTION API
     * Este m√©todo √© chamado quando recebemos webhooks
     */
    async processWebhook(webhookData) {
        try {
            const { event, instance, data } = webhookData;
            
            console.log(`üîî Webhook recebido: ${event} para ${instance}`);
            
            switch (event) {
                case 'QRCODE_UPDATED':
                    return await this.processQRCodeWebhook(instance, data);
                    
                case 'CONNECTION_UPDATE':
                    return await this.processConnectionWebhook(instance, data);
                    
                case 'MESSAGES_UPSERT':
                    return await this.processMessageWebhook(instance, data);
                    
                default:
                    console.log(`‚ÑπÔ∏è Evento n√£o processado: ${event}`);
                    return { success: true, processed: false, event };
            }
            
        } catch (error) {
            console.error('‚ùå Erro ao processar webhook:', error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * üì± PROCESSAR QR CODE RECEBIDO VIA WEBHOOK
     */
    async processQRCodeWebhook(instance, qrData) {
        try {
            console.log(`üì± QR code recebido para ${instance}`);
            
            if (qrData.qrcode) {
                // üíæ Salvar QR code no cache
                this.cacheQRCode(instance, qrData.qrcode);
                
                // Atualizar status da inst√¢ncia
                this.updateInstanceStatus(instance, 'qr_ready');
                
                console.log(`‚úÖ QR code cached para ${instance}`);
                
                return {
                    success: true,
                    action: 'qr_code_cached',
                    instance: instance,
                    cached: true
                };
            }
            
            return {
                success: false,
                error: 'QR code n√£o encontrado no webhook',
                data: qrData
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao processar QR webhook:`, error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * üîó PROCESSAR STATUS DE CONEX√ÉO
     */
    async processConnectionWebhook(instance, connectionData) {
        try {
            console.log(`üîó Conex√£o ${instance}: ${connectionData.state}`);
            
            let status = 'unknown';
            
            switch (connectionData.state) {
                case 'open':
                    status = 'connected';
                    // Limpar QR code do cache quando conectar
                    this.qrCodeCache.delete(instance);
                    console.log(`‚úÖ ${instance} conectado - QR code removido do cache`);
                    break;
                case 'close':
                    status = 'disconnected';
                    break;
                case 'connecting':
                    status = 'connecting';
                    break;
                default:
                    status = connectionData.state;
            }
            
            this.updateInstanceStatus(instance, status);
            
            return {
                success: true,
                action: 'connection_updated',
                instance: instance,
                status: status,
                raw_state: connectionData.state
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao processar conex√£o webhook:`, error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * üí¨ PROCESSAR MENSAGENS (FUTURO)
     */
    async processMessageWebhook(instance, messageData) {
        try {
            console.log(`üí¨ Nova mensagem em ${instance}`);
            
            // Futuramente aqui ser√° integrado com Claude IA
            return {
                success: true,
                action: 'message_received',
                instance: instance,
                processed: false // Por enquanto n√£o processar
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao processar mensagem webhook:`, error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * üíæ CACHE QR CODE RECEBIDO VIA WEBHOOK
     */
    cacheQRCode(instance, qrcode) {
        this.qrCodeCache.set(instance, {
            qrcode: qrcode,
            timestamp: Date.now(),
            expires_at: Date.now() + 300000, // 5 minutos
            status: 'active',
            source: 'webhook'
        });
        
        console.log(`üíæ QR code cached para ${instance} (expira em 5min)`);
    }

    /**
     * üì± OBTER QR CODE DO CACHE
     */
    getCachedQRCode(instance) {
        const cached = this.qrCodeCache.get(instance);
        
        if (!cached) {
            console.log(`‚ùå QR code n√£o encontrado no cache para ${instance}`);
            return null;
        }
        
        // Verificar se expirou
        if (Date.now() > cached.expires_at) {
            console.log(`‚è∞ QR code expirado para ${instance} - removendo do cache`);
            this.qrCodeCache.delete(instance);
            return null;
        }
        
        console.log(`‚úÖ QR code encontrado no cache para ${instance}`);
        return cached;
    }

    /**
     * üîÑ ATUALIZAR STATUS DA INST√ÇNCIA
     */
    updateInstanceStatus(instance, status) {
        const current = this.instanceStatusCache.get(instance) || {};
        
        this.instanceStatusCache.set(instance, {
            ...current,
            status: status,
            last_update: new Date().toISOString()
        });
    }

    /**
     * üìä OBTER STATUS DA INST√ÇNCIA
     */
    getInstanceStatus(instance) {
        return this.instanceStatusCache.get(instance) || {
            status: 'unknown',
            last_update: null
        };
    }

    /**
     * üì± LISTAR INST√ÇNCIAS (API OFICIAL)
     */
    async fetchInstances() {
        try {
            console.log('üì± Buscando inst√¢ncias via Evolution API...');
            
            const response = await axios.get(`${this.apiUrl}/instance/fetchInstances`, {
                headers: this.defaultHeaders,
                timeout: 15000
            });
            
            const instances = response.data.map(instance => ({
                id: instance.name || instance.id,
                name: instance.name || instance.id,
                status: instance.connectionStatus || 'unknown',
                phone: instance.number || null,
                profileName: instance.profileName || null,
                createdAt: instance.createdAt,
                messagesCount: instance._count?.Message || 0,
                contactsCount: instance._count?.Contact || 0,
                chatsCount: instance._count?.Chat || 0
            }));
            
            console.log(`‚úÖ ${instances.length} inst√¢ncias encontradas`);
            
            return {
                success: true,
                data: instances,
                total: instances.length
            };
            
        } catch (error) {
            console.error('‚ùå Erro ao buscar inst√¢ncias:', error.message);
            return {
                success: false,
                error: error.message,
                data: []
            };
        }
    }

    /**
     * üóëÔ∏è DELETAR INST√ÇNCIA
     */
    async deleteInstance(instanceName) {
        try {
            console.log(`üóëÔ∏è Deletando inst√¢ncia ${instanceName}`);
            
            const response = await axios.delete(`${this.apiUrl}/instance/delete/${instanceName}`, {
                headers: this.defaultHeaders,
                timeout: 10000,
                validateStatus: () => true // Aceitar qualquer status
            });
            
            // Limpar caches
            this.qrCodeCache.delete(instanceName);
            this.instanceStatusCache.delete(instanceName);
            
            console.log(`‚úÖ Inst√¢ncia ${instanceName} deletada e cache limpo`);
            
            return {
                success: response.status < 400,
                data: {
                    instanceName: instanceName,
                    status: 'deleted'
                }
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao deletar inst√¢ncia ${instanceName}:`, error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * ‚ùå DESCONECTAR INST√ÇNCIA
     */
    async logoutInstance(instanceName) {
        try {
            console.log(`‚ùå Desconectando inst√¢ncia ${instanceName}`);
            
            const response = await axios.delete(`${this.apiUrl}/instance/logout/${instanceName}`, {
                headers: this.defaultHeaders,
                timeout: 10000
            });
            
            // Limpar QR code do cache
            this.qrCodeCache.delete(instanceName);
            this.updateInstanceStatus(instanceName, 'disconnected');
            
            return {
                success: true,
                data: {
                    instanceName: instanceName,
                    status: 'disconnected'
                }
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao desconectar inst√¢ncia ${instanceName}:`, error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * üìä ESTAT√çSTICAS DO CACHE
     */
    getCacheStats() {
        const qrCodes = Array.from(this.qrCodeCache.entries());
        const activeQRs = qrCodes.filter(([_, data]) => Date.now() < data.expires_at);
        const expiredQRs = qrCodes.length - activeQRs.length;
        
        const instances = Array.from(this.instanceStatusCache.entries());
        
        return {
            qr_codes: {
                total: qrCodes.length,
                active: activeQRs.length,
                expired: expiredQRs
            },
            instances: {
                total: instances.length,
                by_status: instances.reduce((acc, [name, data]) => {
                    acc[data.status] = (acc[data.status] || 0) + 1;
                    return acc;
                }, {})
            },
            webhook_url: this.webhookUrl,
            last_cleanup: new Date().toISOString()
        };
    }

    /**
     * üßπ LIMPEZA DE CACHE EXPIRADO
     */
    cleanExpiredCache() {
        let cleaned = 0;
        
        // Limpar QR codes expirados
        for (const [instance, data] of this.qrCodeCache.entries()) {
            if (Date.now() > data.expires_at) {
                this.qrCodeCache.delete(instance);
                cleaned++;
            }
        }
        
        if (cleaned > 0) {
            console.log(`üßπ ${cleaned} QR codes expirados removidos do cache`);
        }
        
        return cleaned;
    }
}

module.exports = EvolutionWebhookService;