/**
 * üöÄ SOFIA IA - Evolution API Service CORRIGIDO v2
 * Baseado na documenta√ß√£o oficial Evolution API v2
 * https://doc.evolution-api.com/v2/api-reference/instance-controller/create-instance-basic
 * 
 * ‚úÖ CORRE√á√ïES IMPLEMENTADAS:
 * 1. Payload correto baseado na documenta√ß√£o oficial
 * 2. Webhook configuration para receber QR codes
 * 3. Response structure correta
 * 4. Endpoint de conex√£o implementado
 * 5. Fluxo QR code via webhook
 */

const axios = require('axios');

class EvolutionAPIServiceFixed {
    constructor() {
        this.apiUrl = process.env.EVOLUTION_API_URL || 'https://evolutionapi.roilabs.com.br';
        this.apiKey = process.env.EVOLUTION_API_KEY || 'SuOOmamlmXs4NV3nkxpHAy7z3rcurbIz';
        this.webhookUrl = process.env.WEBHOOK_URL || 'https://sofia-ia-api.roilabs.com.br/webhook/evolution';
        
        this.defaultHeaders = {
            'apikey': this.apiKey,
            'Content-Type': 'application/json'
        };
        
        // üì± Storage tempor√°rio para QR codes (em produ√ß√£o usar Redis)
        this.qrCodeCache = new Map();
        
        console.log('üîå Evolution API Service v2 inicializado');
        console.log(`üìç URL: ${this.apiUrl}`);
        console.log(`üîë API Key: ${this.apiKey.substring(0, 10)}...`);
        console.log(`üîî Webhook: ${this.webhookUrl}`);
    }

    /**
     * üÜï Criar nova inst√¢ncia WhatsApp - CORRIGIDO
     * Baseado na documenta√ß√£o oficial Evolution API v2
     */
    async createInstance(instanceName, customSettings = {}) {
        try {
            console.log(`üÜï Criando inst√¢ncia ${instanceName} com payload correto...`);
            
            // ‚úÖ PAYLOAD CORRETO baseado na documenta√ß√£o oficial
            const instanceData = {
                // ‚úÖ Campos obrigat√≥rios
                instanceName: instanceName,
                qrcode: true,
                integration: 'WHATSAPP-BAILEYS',
                
                // ‚úÖ Webhook configuration (CR√çTICO para QR codes)
                webhookUrl: this.webhookUrl,
                webhookByEvents: true,
                webhookBase64: true,
                webhookEvents: [
                    'QRCODE_UPDATED',
                    'CONNECTION_UPDATE',
                    'MESSAGES_UPSERT',
                    'MESSAGE_STATUS_UPDATE',
                    'PRESENCE_UPDATE'
                ],
                
                // ‚úÖ Configura√ß√µes WhatsApp otimizadas
                rejectCall: true,
                msgCall: 'Sofia IA n√£o aceita chamadas de voz. Use mensagens de texto.',
                groupsIgnore: true,
                alwaysOnline: true,
                readMessages: true,
                readStatus: false,
                syncFullHistory: false,
                
                // ‚úÖ Merge com configura√ß√µes customizadas
                ...customSettings
            };
            
            console.log('üì§ Enviando payload:', JSON.stringify(instanceData, null, 2));
            
            const response = await axios.post(`${this.apiUrl}/instance/create`, instanceData, {
                headers: this.defaultHeaders,
                timeout: 30000 // Aumentado para 30s
            });
            
            console.log('‚úÖ Response da cria√ß√£o:', JSON.stringify(response.data, null, 2));
            
            // ‚úÖ STRUCTURE CORRETA do response
            const { instance, hash, settings } = response.data;
            
            // ‚úÖ QR code vir√° via webhook, n√£o no response inicial
            console.log(`üîî Aguardando QR code via webhook para ${instanceName}...`);
            
            return {
                success: true,
                data: {
                    instanceName: instance.instanceName,
                    instanceId: instance.instanceId,
                    status: instance.status,
                    apikey: hash.apikey,
                    settings: settings,
                    
                    // ‚úÖ QR code ser√° atualizado via webhook
                    qrcode: null,
                    qrcodeStatus: 'waiting_webhook',
                    webhookConfigured: true,
                    
                    message: 'Inst√¢ncia criada. QR code ser√° enviado via webhook.'
                }
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao criar inst√¢ncia ${instanceName}:`, error.response?.data || error.message);
            
            // ‚úÖ Se inst√¢ncia j√° existe (409), tentar obter QR
            if (error.response?.status === 409) {
                console.log(`‚ö†Ô∏è Inst√¢ncia ${instanceName} j√° existe, obtendo QR code...`);
                return await this.connectInstance(instanceName);
            }
            
            return {
                success: false,
                error: error.response?.data?.message || error.message,
                statusCode: error.response?.status
            };
        }
    }

    /**
     * üîó Conectar inst√¢ncia (obter QR Code) - IMPLEMENTADO
     * Nova rota baseada na documenta√ß√£o Evolution API v2
     */
    async connectInstance(instanceName) {
        try {
            console.log(`üîó Conectando inst√¢ncia ${instanceName}...`);
            
            // ‚úÖ ROTA CORRETA para conex√£o (gera novo QR)
            const response = await axios.get(`${this.apiUrl}/instance/connect/${instanceName}`, {
                headers: this.defaultHeaders,
                timeout: 20000
            });
            
            console.log('‚úÖ Response da conex√£o:', JSON.stringify(response.data, null, 2));
            
            // ‚úÖ Se QR code vier no response direto
            if (response.data.qrcode) {
                return {
                    success: true,
                    data: {
                        instanceName: instanceName,
                        qrcode: response.data.qrcode,
                        status: 'connecting',
                        source: 'direct_connect'
                    }
                };
            }
            
            // ‚úÖ Sen√£o, aguardar via webhook
            return {
                success: true,
                data: {
                    instanceName: instanceName,
                    qrcode: null,
                    qrcodeStatus: 'waiting_webhook',
                    status: 'connecting',
                    message: 'QR code ser√° enviado via webhook em breve...'
                }
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao conectar ${instanceName}:`, error.response?.data || error.message);
            
            // ‚úÖ Se 404, inst√¢ncia n√£o existe - criar primeiro
            if (error.response?.status === 404) {
                console.log(`üÜï Inst√¢ncia ${instanceName} n√£o encontrada, criando...`);
                return await this.createInstance(instanceName);
            }
            
            return {
                success: false,
                error: error.response?.data?.message || error.message,
                statusCode: error.response?.status
            };
        }
    }

    /**
     * üì± Obter QR Code de inst√¢ncia (consulta cache + API) - NOVO
     */
    async getQRCode(instanceName) {
        try {
            console.log(`üì± Obtendo QR code para ${instanceName}...`);
            
            // ‚úÖ Primeiro verificar cache local
            if (this.qrCodeCache.has(instanceName)) {
                const cached = this.qrCodeCache.get(instanceName);
                
                // ‚úÖ Se cache n√£o expirou (5 min)
                if (Date.now() - cached.timestamp < 300000) {
                    console.log(`üíæ QR code em cache para ${instanceName}`);
                    return {
                        success: true,
                        data: {
                            instanceName: instanceName,
                            qrcode: cached.qrcode,
                            status: cached.status,
                            source: 'cache',
                            cachedAt: new Date(cached.timestamp).toISOString()
                        }
                    };
                } else {
                    // ‚úÖ Cache expirado, remover
                    this.qrCodeCache.delete(instanceName);
                }
            }
            
            // ‚úÖ Tentar obter via API direta
            const routes = [
                `/instance/connect/${instanceName}`,
                `/instance/${instanceName}/qrcode`,
                `/instance/qrcode/${instanceName}`
            ];
            
            for (const route of routes) {
                try {
                    const response = await axios.get(`${this.apiUrl}${route}`, {
                        headers: this.defaultHeaders,
                        timeout: 15000
                    });
                    
                    if (response.data.qrcode || response.data.base64) {
                        const qrcode = response.data.qrcode || response.data.base64;
                        
                        // ‚úÖ Salvar em cache
                        this.qrCodeCache.set(instanceName, {
                            qrcode: qrcode,
                            status: 'active',
                            timestamp: Date.now()
                        });
                        
                        console.log(`‚úÖ QR code obtido via ${route}`);
                        return {
                            success: true,
                            data: {
                                instanceName: instanceName,
                                qrcode: qrcode,
                                status: 'active',
                                source: `api_${route.replace('/', '_')}`
                            }
                        };
                    }
                    
                } catch (routeError) {
                    console.log(`‚ö†Ô∏è Rota ${route} falhou: ${routeError.message}`);
                    continue;
                }
            }
            
            // ‚úÖ Se nenhuma rota funcionou, for√ßar nova conex√£o
            console.log(`üîÑ For√ßando nova conex√£o para ${instanceName}...`);
            return await this.connectInstance(instanceName);
            
        } catch (error) {
            console.error(`‚ùå Erro ao obter QR code:`, error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * üìã Listar inst√¢ncias - MANTIDO
     */
    async listInstances() {
        try {
            const response = await axios.get(`${this.apiUrl}/instance/fetchInstances`, {
                headers: this.defaultHeaders,
                timeout: 15000
            });
            
            const instances = response.data.map(instance => ({
                id: instance.name || instance.instanceName,
                name: instance.name || instance.instanceName,
                status: this.normalizeStatus(instance.connectionStatus),
                phone: instance.number || null,
                profileName: instance.profileName || null,
                profilePicUrl: instance.profilePicUrl || null,
                createdAt: instance.createdAt,
                messagesCount: instance._count?.Message || 0,
                contactsCount: instance._count?.Contact || 0,
                chatsCount: instance._count?.Chat || 0,
                
                // ‚úÖ Adicionar info de QR cache
                hasQRCache: this.qrCodeCache.has(instance.name || instance.instanceName),
                lastQRUpdate: this.qrCodeCache.has(instance.name || instance.instanceName) 
                    ? new Date(this.qrCodeCache.get(instance.name || instance.instanceName).timestamp).toISOString()
                    : null
            }));
            
            return {
                success: true,
                data: instances,
                total: instances.length,
                cached_qrcodes: this.qrCodeCache.size
            };
            
        } catch (error) {
            console.error('‚ùå Erro ao listar inst√¢ncias:', error.message);
            return {
                success: false,
                error: error.message,
                data: []
            };
        }
    }

    /**
     * üîî Processar webhook recebido - IMPLEMENTADO PARA QR CODES
     */
    async processWebhook(webhookData) {
        try {
            const { event, instance, data } = webhookData;
            
            console.log(`üîî Webhook recebido: ${event} para ${instance}`);
            
            switch (event) {
                case 'QRCODE_UPDATED':
                    return await this.processQRCodeWebhook(instance, data);
                    
                case 'CONNECTION_UPDATE':
                    return await this.processConnectionWebhook(instance, data);
                    
                case 'MESSAGES_UPSERT':
                    return await this.processMessageWebhook(instance, data);
                    
                default:
                    console.log(`‚ÑπÔ∏è Evento webhook n√£o processado: ${event}`);
                    return { success: true, processed: false };
            }
            
        } catch (error) {
            console.error('‚ùå Erro ao processar webhook:', error.message);
            return { success: false, error: error.message };
        }
    }

    /**
     * üì± Processar webhook de QR Code - CR√çTICO PARA FUNCIONAR
     */
    async processQRCodeWebhook(instance, qrData) {
        console.log(`üì± QR Code atualizado para ${instance}:`, qrData.qrcode ? 'presente' : 'ausente');
        
        if (qrData.qrcode) {
            // ‚úÖ Salvar QR code em cache
            this.qrCodeCache.set(instance, {
                qrcode: qrData.qrcode,
                status: 'active',
                timestamp: Date.now()
            });
            
            console.log(`üíæ QR code salvo em cache para ${instance}`);
        }
        
        return {
            success: true,
            action: 'qr_updated',
            instance: instance,
            hasQRCode: !!qrData.qrcode
        };
    }

    /**
     * üîó Processar webhook de conex√£o
     */
    async processConnectionWebhook(instance, connectionData) {
        const state = connectionData.state;
        console.log(`üîó Conex√£o atualizada para ${instance}: ${state}`);
        
        // ‚úÖ Se conectou, remover QR code do cache
        if (state === 'open' || state === 'connected') {
            this.qrCodeCache.delete(instance);
            console.log(`üóëÔ∏è QR code removido do cache para ${instance} (conectado)`);
        }
        
        return {
            success: true,
            action: 'connection_updated',
            instance: instance,
            status: state
        };
    }

    /**
     * üí¨ Processar webhook de mensagem
     */
    async processMessageWebhook(instance, messageData) {
        // Implementar integra√ß√£o com Claude IA futuramente
        return {
            success: true,
            action: 'message_received',
            instance: instance,
            from: messageData.key?.remoteJid
        };
    }

    /**
     * ‚öôÔ∏è Utilit√°rios
     */
    normalizeStatus(status) {
        const statusMap = {
            'open': 'connected',
            'close': 'disconnected', 
            'connecting': 'connecting',
            'qr': 'waiting_qr'
        };
        return statusMap[status] || status || 'unknown';
    }

    /**
     * üìä Obter estat√≠sticas do cache QR
     */
    getQRCacheStats() {
        const stats = {
            total: this.qrCodeCache.size,
            instances: [],
            oldestCache: null,
            newestCache: null
        };
        
        let oldest = Infinity;
        let newest = 0;
        
        for (const [instance, data] of this.qrCodeCache.entries()) {
            stats.instances.push({
                instance: instance,
                cachedAt: new Date(data.timestamp).toISOString(),
                ageMinutes: Math.floor((Date.now() - data.timestamp) / 60000)
            });
            
            if (data.timestamp < oldest) {
                oldest = data.timestamp;
                stats.oldestCache = new Date(data.timestamp).toISOString();
            }
            
            if (data.timestamp > newest) {
                newest = data.timestamp;
                stats.newestCache = new Date(data.timestamp).toISOString();
            }
        }
        
        return stats;
    }

    /**
     * üßπ Limpar cache QR expirado
     */
    cleanExpiredQRCache(maxAgeMinutes = 5) {
        const expireTime = Date.now() - (maxAgeMinutes * 60000);
        let cleaned = 0;
        
        for (const [instance, data] of this.qrCodeCache.entries()) {
            if (data.timestamp < expireTime) {
                this.qrCodeCache.delete(instance);
                cleaned++;
            }
        }
        
        if (cleaned > 0) {
            console.log(`üßπ ${cleaned} QR codes expirados removidos do cache`);
        }
        
        return cleaned;
    }

    // ‚úÖ Manter m√©todos existentes (disconnect, delete, send, etc.)
    async disconnectInstance(instanceName) {
        try {
            const response = await axios.delete(`${this.apiUrl}/instance/logout/${instanceName}`, {
                headers: this.defaultHeaders,
                timeout: 10000
            });
            
            // ‚úÖ Limpar cache QR quando desconectar
            this.qrCodeCache.delete(instanceName);
            
            return {
                success: true,
                data: { instanceName, status: 'disconnected' }
            };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    async deleteInstance(instanceName) {
        try {
            const response = await axios.delete(`${this.apiUrl}/instance/delete/${instanceName}`, {
                headers: this.defaultHeaders,
                timeout: 10000
            });
            
            // ‚úÖ Limpar cache QR quando deletar
            this.qrCodeCache.delete(instanceName);
            
            return {
                success: true,
                data: { instanceName, status: 'deleted' }
            };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
}

module.exports = EvolutionAPIServiceFixed;
