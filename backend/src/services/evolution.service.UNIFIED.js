/**
 * üöÄ SOFIA IA - Evolution API Service SIMPLIFICADO
 * Vers√£o: v3.1.0 - Janeiro 2025
 * 
 * SEGUINDO EXATAMENTE A DOCUMENTA√á√ÉO OFICIAL
 */

const axios = require('axios');
const EventEmitter = require('events');

class EvolutionAPIService extends EventEmitter {
    constructor() {
        super();
        
        this.baseURL = process.env.EVOLUTION_API_URL || 'https://evolutionapi.roilabs.com.br';
        this.apiKey = process.env.EVOLUTION_API_KEY || 'SuOOmamlmXs4NV3nkxpHAy7z3rcurbIz';
        this.webhookUrl = process.env.WEBHOOK_URL || 'https://sofiaia.roilabs.com.br/webhook/evolution';
        
        this.qrCodeCache = new Map();
        this.instanceStatus = new Map();
        
        this.defaultHeaders = {
            'apikey': this.apiKey,
            'Content-Type': 'application/json'
        };
        
        console.log('üöÄ Evolution API Service inicializado');
        console.log(`üì° Base URL: ${this.baseURL}`);
        console.log(`üîó Webhook URL: ${this.webhookUrl}`);
    }

    /**
     * üì± CRIAR NOVA INST√ÇNCIA - SEGUINDO EXATAMENTE A DOCUMENTA√á√ÉO OFICIAL
     */
    async createInstance(instanceName, settings = {}) {
        try {
            console.log(`üèóÔ∏è Criando inst√¢ncia: ${instanceName}`);
            
            // ‚úÖ PAYLOAD EXATAMENTE COMO NA DOCUMENTA√á√ÉO OFICIAL
            const instanceData = {
                instanceName: instanceName,
                qrcode: true,
                integration: 'WHATSAPP-BAILEYS',
                rejectCall: true,
                msgCall: 'Sofia IA n√£o aceita chamadas. Use mensagens de texto.',
                groupsIgnore: true,
                alwaysOnline: true,
                readMessages: true,
                readStatus: false,
                syncFullHistory: false,
                
                // ‚úÖ WEBHOOK COMO OBJETO (DOCUMENTA√á√ÉO OFICIAL)
                webhook: {
                    url: this.webhookUrl,
                    byEvents: true,
                    base64: true,
                    events: [
                        'QRCODE_UPDATED',
                        'CONNECTION_UPDATE',
                        'MESSAGES_UPSERT',
                        'MESSAGE_STATUS_UPDATE'
                    ]
                },
                
                ...settings
            };
            
            console.log('üìã Payload sendo enviado:', JSON.stringify(instanceData, null, 2));
            
            const response = await axios.post(`${this.baseURL}/instance/create`, instanceData, {
                headers: this.defaultHeaders,
                timeout: 30000
            });
            
            console.log('‚úÖ Response da Evolution API:', JSON.stringify(response.data, null, 2));
            
            if (response.data && response.data.instance) {
                this.instanceStatus.set(instanceName, {
                    status: 'created',
                    instanceId: response.data.instance.instanceId,
                    createdAt: new Date(),
                    connected: false
                });
                
                console.log(`‚úÖ Inst√¢ncia ${instanceName} criada com sucesso`);
                
                return {
                    success: true,
                    data: {
                        instanceName: instanceName,
                        instanceId: response.data.instance.instanceId,
                        status: 'created',
                        message: 'Inst√¢ncia criada. QR code ser√° enviado via webhook.'
                    }
                };
            }
            
            throw new Error('Response inv√°lido da Evolution API');
            
        } catch (error) {
            console.error(`‚ùå Erro ao criar inst√¢ncia ${instanceName}:`, error.message);
            console.error('üìã Error details:', error.response?.data || 'Sem detalhes');
            
            return {
                success: false,
                error: error.message,
                details: error.response?.data || null
            };
        }
    }

    async listInstances() {
        try {
            const response = await axios.get(`${this.baseURL}/instance/fetchInstances`, {
                headers: this.defaultHeaders,
                timeout: 15000
            });
            
            if (response.data && Array.isArray(response.data)) {
                response.data.forEach(instance => {
                    this.instanceStatus.set(instance.instanceName, {
                        status: instance.status,
                        instanceId: instance.instanceId,
                        connected: instance.status === 'open',
                        lastSeen: new Date()
                    });
                });
                
                return {
                    success: true,
                    data: response.data,
                    count: response.data.length
                };
            }
            
            return {
                success: true,
                data: [],
                count: 0
            };
            
        } catch (error) {
            console.error('‚ùå Erro ao listar inst√¢ncias:', error.message);
            
            return {
                success: false,
                error: error.message,
                data: []
            };
        }
    }

    async connectInstance(instanceName) {
        try {
            console.log(`üîó Conectando inst√¢ncia: ${instanceName}`);
            
            const cachedQR = this.getCachedQRCode(instanceName);
            if (cachedQR) {
                return {
                    success: true,
                    qrcode: cachedQR,
                    source: 'cache',
                    message: 'QR code do cache (ainda v√°lido)'
                };
            }
            
            const response = await axios.get(`${this.baseURL}/instance/connect/${instanceName}`, {
                headers: this.defaultHeaders,
                timeout: 30000
            });
            
            return {
                success: true,
                qrcode: null,
                source: 'webhook_pending',
                message: 'QR code ser√° enviado via webhook em instantes.'
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao conectar ${instanceName}:`, error.message);
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    async deleteInstance(instanceName) {
        try {
            console.log(`üóëÔ∏è Deletando inst√¢ncia: ${instanceName}`);
            
            const response = await axios.delete(`${this.baseURL}/instance/delete/${instanceName}`, {
                headers: this.defaultHeaders,
                timeout: 15000
            });
            
            this.qrCodeCache.delete(instanceName);
            this.instanceStatus.delete(instanceName);
            
            return {
                success: true,
                message: `Inst√¢ncia ${instanceName} deletada`
            };
            
        } catch (error) {
            console.error(`‚ùå Erro ao deletar ${instanceName}:`, error.message);
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    async processWebhook(webhookData) {
        try {
            const { event, instance, data } = webhookData;
            
            console.log(`üîî Webhook recebido: ${event} para ${instance}`);
            console.log(`üìã Data:`, JSON.stringify(data, null, 2));
            
            switch (event) {
                case 'QRCODE_UPDATED':
                    if (data && data.qrcode) {
                        this.cacheQRCode(instance, data.qrcode);
                        this.emit('qrcode_updated', { instance, qrcode: data.qrcode });
                        console.log(`üì± QR code atualizado para ${instance}`);
                    }
                    break;
                    
                case 'CONNECTION_UPDATE':
                    console.log(`üîó Conex√£o ${instance}: ${data.state}`);
                    
                    const currentStatus = this.instanceStatus.get(instance) || {};
                    currentStatus.connected = data.state === 'open';
                    currentStatus.status = data.state;
                    currentStatus.lastSeen = new Date();
                    this.instanceStatus.set(instance, currentStatus);
                    
                    if (data.state === 'open') {
                        this.qrCodeCache.delete(instance);
                        this.emit('instance_connected', { instance });
                        console.log(`‚úÖ ${instance} conectado com sucesso!`);
                    } else if (data.state === 'close') {
                        this.emit('instance_disconnected', { instance });
                    }
                    break;
                    
                case 'MESSAGES_UPSERT':
                    if (data && data.messages) {
                        for (const message of data.messages) {
                            this.emit('message_received', { instance, message });
                        }
                        console.log(`üí¨ ${data.messages.length} mensagens recebidas em ${instance}`);
                    }
                    break;
                    
                case 'MESSAGE_STATUS_UPDATE':
                    this.emit('message_status', { instance, status: data });
                    break;
            }
            
            return { 
                success: true, 
                event, 
                instance,
                processed: true 
            };
            
        } catch (error) {
            console.error('‚ùå Erro ao processar webhook:', error);
            
            return {
                success: false,
                error: error.message
            };
        }
    }

    cacheQRCode(instance, qrcode) {
        this.qrCodeCache.set(instance, {
            qrcode: qrcode,
            timestamp: Date.now(),
            status: 'active'
        });
        console.log(`üíæ QR code cached para ${instance}`);
    }

    getCachedQRCode(instance) {
        const cached = this.qrCodeCache.get(instance);
        if (!cached) return null;
        
        if (Date.now() - cached.timestamp > 300000) {
            this.qrCodeCache.delete(instance);
            return null;
        }
        
        return cached.qrcode;
    }

    getServiceStats() {
        return {
            totalInstances: this.instanceStatus.size,
            connectedInstances: Array.from(this.instanceStatus.values())
                .filter(status => status.connected).length,
            cachedQRCodes: this.qrCodeCache.size,
            baseURL: this.baseURL,
            webhookURL: this.webhookUrl,
            uptime: process.uptime()
        };
    }

    async healthCheck() {
        try {
            const response = await axios.get(`${this.baseURL}/instance/fetchInstances`, {
                headers: this.defaultHeaders,
                timeout: 10000
            });
            
            return {
                success: true,
                status: 'healthy',
                responseTime: response.headers['x-response-time'] || 'unknown',
                timestamp: new Date().toISOString()
            };
            
        } catch (error) {
            return {
                success: false,
                status: 'unhealthy',
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
}

module.exports = EvolutionAPIService;